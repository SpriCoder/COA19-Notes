homework02
---
1. 表示存储的时候: MB | Mb 中的M是指的是2<sup>?</sup>
2. 表示其他的时候: Mbps | MBps 中的M指的是10<sup>?</sup>
3. Eg. MB/s:我们避免这种写法，不好确定是2还是10为底
    + 1 bits / 100 ns = 10 Mbps
4. 第一题第二问:既有位扩展也有字扩展
    + 扩展到32位，我们只需要同时访问4个8位存储器的相同的位置即可。
5. 第二题:
    1. 1K * 4 -> 64 K * 1B:1K -> 64K的字扩展，4 bits -> 1B位扩展
    2. 寻址空间由容量决定，片内地址由片内存储单元决定
        + 选片不是每个片来选，而是2个选一次(因为字扩展)，所以选片用了6个地址。
    3. 位扩展的时候我们使用的是一个地址。
6. 第三题:
    1. 地址空间32K
    2. 所以32K = 2<sup>15</sup>(答案有误)
    3. 2(15-13)位选片，13位片内选址，先算片内选址。

homework03
---
# 1. 第一题
1. 数据区大小:不算Tag仅仅含有数据区
2. 只说cache大小的时候我们也认为是数据区(不考虑Tag)
3. 只有在强调Tag的存在的时候我们才认为包含Tag
4. 假设访问cache的时间为T，访问主存时间为10T，命中概率P(至少要写的部分)，那么提高的速度是10T/(T+(1-p)*10T) = 10 / (11-10p)
5. 32K = 2<sup>15</sup>，所以一共15位，4K/64 * 4 = 2<sup>4</sup>，也就是组号4位(组数log<sub>2</sub>)，64 = 2<sup>6</sup>
6. 第一轮访问了4352次，68次未命中，剩下的被加载命中
7. 例子如下:第一组:0 + 16 + 32 + 48,第二组:15 + 31 + 47 + 63,然后把64、65、66、67加载到0,1,2,3
8. 第二轮及以后:会未命中5*4 = 20次，所以我们可以证明从第三轮到第十轮都是一样的(虽然每个组内数据不同，但是等价，要替换的数据是一样的)
9. p =(68 + 20 * 9)/4352 * 10
10. 就是因为多了4个标记，才会大量的未命中，不然在第二轮在以后不会有未命中。
11. 改成4350在未改变除法向上取整的时候，只会影响p计算中的分母的部分，而不会影响未命中的次数。
    + 因为在cache中访问是按照块来访问，所以块的第一个开始取用，还是从同一个块的最后一个开始取用。
    + 也就是我们只需要考虑访问多少次块即可。

# 2. 第二题

## 2.1. 第一问
1. 做题前把cache和memory都画出来。
2. 第一次:63、64没有命中，8 miss 2
3. 之后第一次循环:15miss、16miss、32miss、80miss(34 miss 4)
    + cache:0523
4. 第二次循环：16miss、80miss(34 miss 2)
5. 之后每次循环都是相同的情况

## 2.2. 第二问
1. 第一次(8 miss 2)
2. 第一次循环(34 miss 4)
    + 第一轮结束情况时2051
3. 之后没有不命中的。

# 3. 第三题
1. 1 ns + (1 - 0.95) * T > 1.5 + (1 - 0.97) * T
2. 所以速度是主存的 25 / 1.5 = 17倍以上

# 4. 第四题
略过

# 5. 第五题
1. n2要确定是局部缺失率还是全局缺失率，如果是局部缺失率则还需要进行计算

# 6. 第六题
1. a[1][1]的地址的计算需要看a有多大:320 + 256 * 4 + 1 * 4

# 7. 第七题
1. 每组4行，4路组。
2. 字是寻址的最基本单位。

homework09
---

# 8. 第一题
1. 不同循环使用不同的状态图，外层再次进入内层，则继续使用状态图，进入n次，每次判断n+1层。

homework10
---

# 9. IO部分
1. 常见设问:
2. I/O方式能不能支撑数据传输
3. 在最坏的情况下进行判断能用不能用，只要在不能用的情况下不能用，则不能使用。
4. CPU占用时间是多少，CPU占用时间的比例是多少。
5. 打印机是用buffer来进行打印
6. 中断式I/O的部分问题
    1. 选择15，因为在100中已经完成了一字节的传递
    2. 会受到Buffer的影响，时间受到处理时间和传送时间的同时影响
7. 时间问题:
    1. 第一种情况:输入时间比搬运时间快
        + 头时间加上所有的处理时间
    2. 第二种情况:搬运时间比输入时间快
        + 传输时间加上小尾巴时间(小尾巴包含CPU参与以及CPU不参与的时间，不一定是一个数据，可能有很多的数据，还有可能是DMA的搬运时间处理时间等)
    3. 总体来讲是加上慢一点的

# 10. 第五题
1. 保证 60+1000 的过程中不能来新的数据
2. 判断能不能用:需要比较上面的时间和处理器处理时间是否合适。
3. 1200个时间周期是包含1000个的时间周期
4. 如果时间不够可以不计算结果，结果不对只有1分
5. 注意有没有分别，2000*2
6. 题目没有说的事情，往简单说可以，比如**假设没有访问冲突**
7. 加上小尾巴，直接拿2000*1ns是不对的
    + 为什么?最后一次的时候，DMA先进行初始化，然后自己**搬一下数据**，然后进行处理
    + 而在之前的中断等问题中，是没有搬运时间的。

# 第七题
1. 按照最坏情况进行计算